# Feature: Complete Library Setup

## Goal

Automatically set up the `lib` directory infrastructure so that `lib/mkApp.nix` is properly integrated into your NixOS flake and can be imported by generated modules.

## Current Situation

Your `initialSetup()` function (install.go:177) currently:

- ‚úÖ Creates `lib/` directory
- ‚úÖ Creates `lib/mkApp.nix` from template

But the TODOs say it should also:

- ‚ùå Check/create `lib/default.nix` to export mkApp
- ‚ùå Verify `flake.nix` has lib registered in outputs
- ‚ùå Update `flake.nix` if needed

## Why This Matters

Without proper setup, the generated module files can't import `mkApp`:

```nix
# Generated module (e.g., apps/dev-tools/vim.nix)
{ lib, config, pkgs, ... }:
let
  mkApp = lib.mkApp;  # This will fail if lib doesn't export mkApp!
in {
  # ...
}
```

---

## Nix/Flake Concepts

### What is lib/default.nix?

In Nix, `lib/default.nix` is the entry point for a library directory:

```nix
# lib/default.nix
{
  mkApp = import ./mkApp.nix;
  # other functions...
}
```

It's an "index" that exports all your library functions.

### What is flake.nix outputs.lib?

Your flake needs to expose the lib functions:

```nix
# flake.nix
{
  outputs = { self, nixpkgs }: {
    lib = import ./lib { };  # Makes lib functions available

    nixosConfigurations = {
      myhost = nixpkgs.lib.nixosSystem {
        modules = [
          ({ lib, ... }: {
            # Now lib.mkApp is available here!
          })
        ];
      };
    };
  };
}
```

---

## Design Decisions

### 1. How to Modify Nix Files?

**Option A: String Manipulation**

- Pros: Simple, no dependencies
- Cons: Fragile, can break formatting
- Works for: Simple insertions with clear patterns

**Option B: Parse Nix AST**

- Pros: Robust, preserves formatting
- Cons: Complex, need Nix parsing library
- Reality: No good Go library for Nix parsing

**Option C: Template Approach**

- Pros: Clean, controlled
- Cons: Overwrites existing content
- Use when: File doesn't exist yet

**Recommendation**: Use string manipulation carefully with clear patterns. Document expected format.

### 2. What if User Has Custom lib/default.nix?

Their file might look like:

```nix
{
  myCustomFunction = ...;
  mkApp = import ./mkApp.nix;  # Already has mkApp!
}
```

**Should you**:

- Skip if mkApp already exists? (Safest)
- Error and ask user to fix manually?
- Attempt to merge intelligently?

### 3. What if flake.nix Structure is Different?

Not all flakes are structured the same:

```nix
# Some users might have:
outputs = { ... }: rec {
  lib = { ... };
}

# Others might have:
outputs = inputs@{ ... }:
  let lib = import ./lib; in { ... }
```

**Challenge**: You can't handle every possible flake structure.

**Solution**: Document expected structure and provide helpful errors.

---

## Implementation Hints

### Phase 1: Check lib/default.nix

```go
func ensureLibDefault(libPath string) error {
    defaultPath := filepath.Join(libPath, "default.nix")

    // Does it exist?
    if _, err := os.Stat(defaultPath); err == nil {
        // File exists - should you check if mkApp is already exported?
        // How would you check?
        return nil
    }

    // Doesn't exist - create it
    // What should the content be?
}
```

**Questions**:

1. If file exists, how do you check if it exports `mkApp`?
   - Read file, search for pattern `mkApp = `?
   - Just assume it's correct?
2. What should a fresh `lib/default.nix` contain?

**Template suggestion**:

```nix
# lib/default.nix
# Generated by pam - you can customize this file
{
  mkApp = import ./mkApp.nix;
}
```

### Phase 2: Check flake.nix

This is trickier! Consider:

```go
func ensureFlakeHasLib(flakePath string) error {
    flakeNixPath := filepath.Join(flakePath, "flake.nix")

    // Read flake.nix
    content, err := os.ReadFile(flakeNixPath)
    if err != nil {
        // What if flake.nix doesn't exist?
        return err
    }

    // Check if 'lib' is in outputs
    // How do you detect this?
    hasLib := checkForLib(content)

    if !hasLib {
        // Need to add lib to outputs
        // Where/how to add it?
    }

    return nil
}
```

**Pattern matching ideas**:

```go
// Look for patterns like:
"outputs = { ... }: {\n  lib = "
"outputs.lib"
"lib = import ./lib"
```

### Phase 3: Modifying flake.nix

If `lib` is not in outputs, where should you add it?

**Expected structure**:

```nix
{
  outputs = { self, nixpkgs, ... }: {
    lib = import ./lib;  # ADD THIS LINE

    nixosConfigurations = {
      # ...
    };
  };
}
```

**String manipulation approach**:

```go
func addLibToFlake(content string) string {
    // Find the outputs = { ... }: { pattern
    // Insert "lib = import ./lib;" after the opening brace

    // What pattern do you search for?
    // How do you handle different formatting?
}
```

**Key patterns to look for**:

```
outputs = { ... }: {
  ^^^^^^^^^^^^^^^^^^ Find this
    [INSERT HERE]
    lib = import ./lib;

    nixosConfigurations = ...
```

---

## Edge Cases to Handle

### 1. flake.nix Already Has lib

```nix
outputs = { ... }: {
  lib = myCustomLib;  # User has their own lib!
};
```

**Action**: Don't overwrite! Either:

- Skip with message: "lib already exists in flake.nix"
- Error: "Please merge lib manually"
- Try to detect if it imports `./lib`

### 2. flake.nix Has Unusual Format

```nix
outputs = inputs@{ self, nixpkgs }: let
  lib = import ./lib;
in {
  inherit lib;
  nixosConfigurations = ...;
}
```

**Action**: Your pattern matching might not work. Provide helpful error:

```
Error: Could not automatically update flake.nix
Please ensure your flake.nix exports lib:
  outputs = { ... }: {
    lib = import ./lib;
  }
```

### 3. File Permissions

User might not have write access to flake.nix.

**Action**: Handle `os.WriteFile` errors gracefully.

### 4. Backup Safety

Modifying flake.nix is risky!

**Ideas**:

- Create backup: `flake.nix.bak`
- Use git to detect changes
- Ask for confirmation before modifying

---

## String Patterns for Flake Parsing

### Detecting if lib exists

```go
func flakeHasLib(content []byte) bool {
    str := string(content)

    // Look for common patterns
    patterns := []string{
        "lib = import ./lib",
        "lib = import ./lib;",
        "outputs.lib",
        // What other patterns?
    }

    for _, pattern := range patterns {
        if strings.Contains(str, pattern) {
            return true
        }
    }
    return false
}
```

**Question**: Is this robust enough? What patterns might you miss?

### Adding lib to outputs

```go
func addLibToOutputs(content string) (string, error) {
    // Find where to insert
    // Pattern: "outputs = { ... }: {"
    //   Then find the opening { of the outputs set
    //   Insert after that

    marker := "outputs ="
    startIdx := strings.Index(content, marker)
    if startIdx == -1 {
        return "", fmt.Errorf("could not find 'outputs =' in flake.nix")
    }

    // Now find the { that starts the output set
    // This is tricky - might be multiple { characters
    // How do you find the right one?

    // Simple approach: find next {, then next \n, insert after
    // More robust: count braces to find matching one?
}
```

**Challenge**: Nix syntax is complex. String manipulation is fragile.

---

## Safety Measures

### 1. Dry Run / Validation

Before making changes:

```go
func validateFlakeStructure(flakePath string) error {
    // Check flake.nix is parsable (by nix)
    cmd := exec.Command("nix", "flake", "check", "--no-build", flakePath)
    return cmd.Run()
}
```

### 2. Backups

```go
func backupFlake(flakePath string) error {
    src := filepath.Join(flakePath, "flake.nix")
    dst := filepath.Join(flakePath, "flake.nix.backup")

    input, err := os.ReadFile(src)
    if err != nil {
        return err
    }

    return os.WriteFile(dst, input, 0644)
}
```

### 3. Git Integration

```go
func flakeInGit(flakePath string) bool {
    cmd := exec.Command("git", "-C", flakePath, "status")
    return cmd.Run() == nil
}

// Suggest user commit changes
fmt.Println("Tip: Your flake.nix was modified. Consider: git commit -m 'Setup pam lib'")
```

---

## User Experience Considerations

### Interactive Mode

```go
func initialSetup() error {
    // ... create lib/mkApp.nix ...

    if needsLibDefault() {
        fmt.Println("Creating lib/default.nix...")
        createLibDefault()
    }

    if !flakeHasLib() {
        fmt.Println("\n‚ö†Ô∏è  Your flake.nix needs to export lib.")
        fmt.Println("Would you like pam to update it automatically? [y/N]: ")

        var response string
        fmt.Scanln(&response)

        if strings.ToLower(response) == "y" {
            updateFlake()
        } else {
            fmt.Println("\nPlease add this to your flake.nix manually:")
            fmt.Println("  outputs = { ... }: {")
            fmt.Println("    lib = import ./lib;")
            fmt.Println("    ...")
            fmt.Println("  }")
        }
    }
}
```

**Pro**: Safer, user has control
**Con**: Extra step, not fully automatic

### Silent Mode with Warning

```go
if !flakeHasLib() {
    fmt.Println("‚ö†Ô∏è  Warning: lib not found in flake.nix")
    fmt.Println("Generated modules may not work correctly.")
    fmt.Println("See: docs/setup.md for manual setup")
}
```

**Pro**: Non-intrusive
**Con**: User might not fix it

---

## Testing Strategy

### Test Case 1: Fresh Setup

- No `lib/` directory
- Empty flake.nix (or standard structure)
- Should create everything

### Test Case 2: lib/ Exists, default.nix Missing

- `lib/mkApp.nix` exists
- `lib/default.nix` doesn't exist
- Should create default.nix

### Test Case 3: Everything Already Set Up

- `lib/default.nix` has mkApp
- `flake.nix` exports lib
- Should skip, no modifications

### Test Case 4: Custom lib/default.nix

- User has their own functions in default.nix
- Should detect mkApp exists, skip

### Test Case 5: Unusual flake.nix

- Non-standard structure
- Should fail gracefully with helpful message

---

## Implementation Levels

### Level 1: Basic (Easiest)

- Create `lib/default.nix` if missing
- Print warning if flake.nix might need updates
- Don't auto-modify flake.nix

### Level 2: Detection (Medium)

- Create `lib/default.nix` if missing
- Detect if flake.nix has lib
- Print specific instructions if missing

### Level 3: Interactive (Advanced)

- Create `lib/default.nix` if missing
- Detect if flake.nix has lib
- Offer to update flake.nix automatically
- Ask for confirmation

### Level 4: Automatic (Expert)

- Fully automatic setup
- Safe modification of flake.nix
- Backup before changes
- Validation after changes

**Recommendation for v1**: Start with Level 1 or 2. Level 3/4 can come later.

---

## Template Files

### lib/default.nix Template

```nix
# lib/default.nix
# Custom library functions for your NixOS configuration
# Generated by pam: https://github.com/yourusername/pam

{
  # Package module generator
  # Used by pam-generated modules in modules/apps/
  mkApp = import ./mkApp.nix;

  # Add your custom functions here:
  # myFunction = ...;
}
```

### Documentation to Generate

When setup completes, create `lib/README.md`:

```markdown
# Library Functions

This directory contains custom Nix library functions.

## mkApp.nix

Generated by `pam` - creates package modules with enable options.

## Adding Custom Functions

Edit `default.nix` to add your own helper functions.
```

---

## Questions to Think About

1. **Risk tolerance**: How much should you automate vs ask user?
2. **Error recovery**: What if modification breaks flake.nix?
3. **User expertise**: Assume user knows Nix well or provide guidance?
4. **Validation**: How do you test if flake still works after changes?
5. **Standards**: Should you enforce a specific flake structure?

---

## Implementation Steps

### Step 1: lib/default.nix Handling

1. Check if exists
2. If exists, verify mkApp is exported (optional)
3. If not, create from template
4. Test with existing and non-existing files

### Step 2: flake.nix Detection

1. Read flake.nix
2. Search for lib in outputs
3. Return boolean: has lib or not

### Step 3: User Communication

1. If lib missing, print warning/instructions
2. Optionally, ask if user wants auto-update
3. Provide clear manual setup instructions

### Step 4: (Optional) flake.nix Modification

1. Parse flake.nix carefully
2. Find insertion point
3. Add lib = import ./lib;
4. Write back, create backup first

### Step 5: Testing

1. Test with standard flake structure
2. Test with unusual structures
3. Test safety measures (backups, validation)

---

## Resources

- **Nix Flakes**: https://nixos.wiki/wiki/Flakes
- **Nix Language**: https://nixos.org/manual/nix/stable/language/
- **lib in nixpkgs**: https://github.com/NixOS/nixpkgs/tree/master/lib

---

## Bonus Ideas

1. **Setup wizard**: `pam init` for first-time setup
2. **Doctor command**: `pam doctor` checks if everything is configured
3. **Migration guide**: Help users coming from other tools
4. **Validation**: `nix flake check` after modifications
5. **Rollback**: Undo setup changes if something breaks

Good luck! This feature makes your tool more robust and production-ready. Start simple and iterate! üèóÔ∏è
